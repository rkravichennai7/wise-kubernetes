name: CI/CD for Wisecow

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: rkravichennai7/wisecow

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Log in to registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=latest
            type=sha

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

  deploy:
    needs: build-and-push
    runs-on: [self-hosted, windows, minikube]

    steps:
      - uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: latest

      - name: Configure kubeconfig (from secret)
        shell: powershell
        run: |
          $b64 = $env:KUBECONFIG_B64
          if ([string]::IsNullOrWhiteSpace($b64)) { throw "KUBECONFIG_B64 secret is empty" }
          $out = Join-Path $env:RUNNER_TEMP 'kubeconfig'
          [IO.File]::WriteAllBytes($out, [Convert]::FromBase64String($b64))
          "KUBECONFIG=$out" | Out-File -FilePath $env:GITHUB_ENV -Encoding ASCII -Append

      - name: Verify cluster context
        shell: powershell
        run: |
          kubectl version --client
          kubectl config get-contexts || exit 1
          # If you're on minikube, uncomment the next line:
          # kubectl config use-context minikube
          kubectl cluster-info

      - name: Deploy with retries and diagnostics
        shell: powershell
        env:
          KUBECONFIG: ${{ runner.temp }}\kubeconfig
          NAMESPACE: default   # change if you use another namespace
          DEPLOYMENT: wisecow  # change if your deployment name differs
        run: |
          $ErrorActionPreference = 'Stop'

          function Invoke-WithRetry([scriptblock]$Block, [int]$Attempts = 3, [int]$DelaySec = 5) {
            for ($i=1; $i -le $Attempts; $i++) {
              try { & $Block; return } catch {
                if ($i -eq $Attempts) { throw }
                Start-Sleep -Seconds $DelaySec
              }
            }
          }

          Write-Host "==> Applying manifests"
          Invoke-WithRetry { kubectl apply -f k8s/cert-issuer.yaml }  # may be optional in minikube
          Invoke-WithRetry { kubectl apply -f k8s/deployment.yaml -n $env:NAMESPACE }
          Invoke-WithRetry { kubectl apply -f k8s/service.yaml     -n $env:NAMESPACE }
          Invoke-WithRetry { kubectl apply -f k8s/ingress.yaml     -n $env:NAMESPACE }

          Write-Host "==> Waiting for rollout"
          try {
            kubectl rollout status deployment/$env:DEPLOYMENT -n $env:NAMESPACE --timeout=180s
            Write-Host "Deployment rolled out successfully."
          } catch {
            Write-Warning "Rollout did not complete in time. Gathering diagnostics..."
            kubectl get deploy/$env:DEPLOYMENT -n $env:NAMESPACE -o yaml > $env:RUNNER_TEMP\deploy.yaml
            kubectl get pods -n $env:NAMESPACE -o wide
            kubectl describe deploy/$env:DEPLOYMENT -n $env:NAMESPACE || $true
            kubectl describe pods -l app=$env:DEPLOYMENT -n $env:NAMESPACE || $true
            # Show logs of the newest pod (if any)
            $pod = (kubectl get pods -n $env:NAMESPACE -l app=$env:DEPLOYMENT -o name | Select-Object -First 1)
            if ($pod) { kubectl logs $pod -n $env:NAMESPACE --tail=200 || $true }
            throw "Rollout failed or timed out."
          }

